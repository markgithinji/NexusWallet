package com.example.nexuswallet


import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.horizontalScroll
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.AccountBalanceWallet
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Backup
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.Circle
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.CurrencyBitcoin
import androidx.compose.material.icons.filled.Diamond
import androidx.compose.material.icons.filled.Error
import androidx.compose.material.icons.filled.Fingerprint
import androidx.compose.material.icons.filled.Security
import androidx.compose.material.icons.filled.Warning
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.navigation.NavController
import com.example.nexuswallet.data.model.CryptoWallet
import com.example.nexuswallet.data.model.WalletType

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun WalletCreationScreen(
    navController: NavController,
    viewModel: WalletCreationViewModel = viewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val currentStep by viewModel.currentStep.collectAsState()
    val selectedType by viewModel.selectedWalletType.collectAsState()
    val mnemonic by viewModel.mnemonic.collectAsState()
    val walletName by viewModel.walletName.collectAsState()
    val isMnemonicGenerated by viewModel.isMnemonicGenerated.collectAsState()

    // Track if user has seen the mnemonic warning
    var hasSeenSecurityWarning by remember { mutableStateOf(false) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Create Wallet") },
                navigationIcon = {
                    if (currentStep > 0) {
                        IconButton(onClick = {
                            if (currentStep == 1 && !hasSeenSecurityWarning) {
                                navController.navigateUp()
                            } else {
                                viewModel.previousStep()
                            }
                        }) {
                            Icon(Icons.Default.ArrowBack, "Back")
                        }
                    }
                }
            )
        }
    ) { padding ->
        // Show loading only for step 0-3, not for success step
        if (currentStep < 4 && uiState is WalletCreationUiState.Loading) {
            LoadingScreen()
            return@Scaffold
        }

        // Show error only for step 0-3
        if (currentStep < 4 && uiState is WalletCreationUiState.Error) {
            ErrorScreen(
                message = (uiState as WalletCreationUiState.Error).message,
                onRetry = { viewModel.reset() }
            )
            return@Scaffold
        }

        WalletCreationStepper(
            currentStep = currentStep,
            selectedWalletType = selectedType,
            padding = padding,
            content = {
                when (currentStep) {
                    0 -> WalletTypeSelectionStep(
                        selectedType = selectedType,
                        onTypeSelected = { viewModel.setWalletType(it) },
                        onNext = {
                            viewModel.nextStep()
                        }
                    )

                    1 -> {
                        if (!hasSeenSecurityWarning) {
                            SecurityWarningDialog(
                                onAccept = {
                                    hasSeenSecurityWarning = true
                                    if (!isMnemonicGenerated) {
                                        viewModel.generateMnemonic()
                                    }
                                },
                                onCancel = {
                                    viewModel.previousStep()
                                }
                            )
                        }

                        if (hasSeenSecurityWarning) {
                            if (mnemonic.isNotEmpty()) {
                                MnemonicDisplayStep(
                                    mnemonic = mnemonic,
                                    onNext = {
                                        viewModel.nextStep()
                                    },
                                    onBack = {
                                        viewModel.previousStep()
                                    }
                                )
                            } else {
                                Box(
                                    modifier = Modifier.fillMaxSize(),
                                    contentAlignment = Alignment.Center
                                ) {
                                    Column(
                                        horizontalAlignment = Alignment.CenterHorizontally
                                    ) {
                                        CircularProgressIndicator()
                                        Spacer(modifier = Modifier.height(16.dp))
                                        Text("Generating secure recovery phrase...")
                                    }
                                }
                            }
                        }
                    }

                    2 -> {
                        MnemonicVerificationStep(
                            viewModel = viewModel,
                            onNext = { viewModel.nextStep() },
                            onBack = {
                                viewModel.previousStep()
                            }
                        )
                    }

                    3 -> WalletNameStep(
                        walletName = walletName,
                        onNameChange = { viewModel.setWalletName(it) },
                        onCreate = {
                            viewModel.createWallet()
                        }
                    )

                    4 -> {
                        // STEP 4: Success - Check if wallet was created
                        when (uiState) {
                            is WalletCreationUiState.WalletCreated -> {
                                val wallet = (uiState as WalletCreationUiState.WalletCreated).wallet
                                WalletSuccessStep(
                                    wallet = wallet,
                                    onFinish = {
                                        // Save wallet to storage and navigate
                                        saveWalletAndNavigate(navController, wallet)
                                    }
                                )
                            }
                            is WalletCreationUiState.Loading -> {
                                // Still creating wallet
                                Box(
                                    modifier = Modifier.fillMaxSize(),
                                    contentAlignment = Alignment.Center
                                ) {
                                    Column(
                                        horizontalAlignment = Alignment.CenterHorizontally
                                    ) {
                                        CircularProgressIndicator()
                                        Spacer(modifier = Modifier.height(16.dp))
                                        Text("Creating wallet...")
                                    }
                                }
                            }
                            else -> {
                                // Something went wrong, go back
                                LaunchedEffect(Unit) {
                                    viewModel.previousStep() // Go back to name step
                                }
                                LoadingScreen()
                            }
                        }
                    }
                }
            }
        )
    }
}

// Helper function to save wallet and navigate
private fun saveWalletAndNavigate(navController: NavController, wallet: CryptoWallet) {
    // Save wallet to your data manager/storage
    val walletDataManager = NexusWalletApplication.instance.walletDataManager
    walletDataManager.saveWallet(wallet)

    // Navigate to dashboard
    navController.navigate("dashboard") {
        popUpTo("createWallet") { inclusive = true }
    }
}

@Composable
fun WalletCreationStepper(
    currentStep: Int,
    selectedWalletType: WalletType,
    padding: PaddingValues,
    content: @Composable () -> Unit
) {
    // Create dynamic step labels based on wallet type
    val steps = when (selectedWalletType) {
        WalletType.BITCOIN -> listOf(
            "Bitcoin",      // Step 0
            "Backup",       // Step 1 (Show mnemonic)
            "Verify",       // Step 2 (Type verification)
            "Name",         // Step 3
            "Complete"      // Step 4
        )
        WalletType.ETHEREUM -> listOf(
            "Ethereum",     // Step 0
            "Backup",       // Step 1
            "Verify",       // Step 2
            "Name",         // Step 3
            "Complete"      // Step 4
        )
        WalletType.MULTICHAIN -> listOf(
            "Type",         // Step 0
            "Backup",       // Step 1
            "Verify",       // Step 2
            "Name",         // Step 3
            "Complete"      // Step 4
        )
        else -> listOf("Type", "Backup", "Verify", "Name", "Complete")
    }

    // Step descriptions for better UX
    val stepDescriptions = remember(currentStep) {
        when (currentStep) {
            0 -> "Select your wallet type"
            1 -> "Backup your recovery phrase"
            2 -> "Verify your backup"
            3 -> "Personalize your wallet"
            4 -> "Wallet created successfully"
            else -> ""
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(padding)
    ) {
        // Progress header with description
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp, vertical = 12.dp)
        ) {
            // Current step indicator
            Text(
                text = "Step ${currentStep + 1} of ${steps.size}",
                style = MaterialTheme.typography.labelMedium,
                color = MaterialTheme.colorScheme.primary,
                fontWeight = FontWeight.Medium
            )

            Spacer(modifier = Modifier.height(4.dp))

            // Step description
            Text(
                text = stepDescriptions,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }

        // Visual step indicators
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 24.dp, vertical = 8.dp),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            steps.forEachIndexed { index, step ->
                StepIndicator(
                    stepNumber = index + 1,
                    stepName = step,
                    isActive = index == currentStep,
                    isCompleted = index < currentStep,
                    isNext = index == currentStep + 1
                )
            }
        }

        // Progress bar
        LinearProgressIndicator(
            progress = { (currentStep + 1) / steps.size.toFloat() },
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp, vertical = 4.dp)
                .height(4.dp),
            color = MaterialTheme.colorScheme.primary,
            trackColor = MaterialTheme.colorScheme.surfaceVariant
        )

        Spacer(modifier = Modifier.height(24.dp))

        // Content
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(horizontal = 16.dp)
        ) {
            content()
        }
    }
}

@Composable
fun StepIndicator(
    stepNumber: Int,
    stepName: String,
    isActive: Boolean,
    isCompleted: Boolean,
    isNext: Boolean = false
) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.width(50.dp)
    ) {
        // Circle indicator
        Box(
            modifier = Modifier
                .size(36.dp)
                .clip(CircleShape)
                .background(
                    color = when {
                        isCompleted -> MaterialTheme.colorScheme.primary
                        isActive -> MaterialTheme.colorScheme.primaryContainer
                        isNext -> MaterialTheme.colorScheme.primary.copy(alpha = 0.1f)
                        else -> MaterialTheme.colorScheme.surfaceVariant
                    }
                )
                .border(
                    width = if (isActive) 2.dp else 0.dp,
                    color = MaterialTheme.colorScheme.primary,
                    shape = CircleShape
                ),
            contentAlignment = Alignment.Center
        ) {
            if (isCompleted) {
                Icon(
                    imageVector = Icons.Default.Check,
                    contentDescription = "Completed",
                    tint = MaterialTheme.colorScheme.onPrimary,
                    modifier = Modifier.size(18.dp)
                )
            } else {
                Text(
                    text = stepNumber.toString(),
                    color = when {
                        isActive -> MaterialTheme.colorScheme.onPrimaryContainer
                        isNext -> MaterialTheme.colorScheme.primary
                        else -> MaterialTheme.colorScheme.onSurfaceVariant
                    },
                    fontWeight = FontWeight.Bold
                )
            }
        }

        Spacer(modifier = Modifier.height(8.dp))

        // Step name
        Text(
            text = stepName,
            style = MaterialTheme.typography.labelSmall,
            color = when {
                isActive || isCompleted -> MaterialTheme.colorScheme.primary
                isNext -> MaterialTheme.colorScheme.primary.copy(alpha = 0.8f)
                else -> MaterialTheme.colorScheme.onSurfaceVariant
            },
            fontWeight = if (isActive) FontWeight.Bold else FontWeight.Normal,
            maxLines = 1,
            overflow = TextOverflow.Ellipsis
        )
    }
}

@Composable
fun WalletTypeSelectionStep(
    selectedType: WalletType,
    onTypeSelected: (WalletType) -> Unit,
    onNext: () -> Unit
) {
    Column {
        Text(
            text = "Select Wallet Type",
            style = MaterialTheme.typography.headlineSmall,
            fontWeight = FontWeight.Bold
        )

        Spacer(modifier = Modifier.height(16.dp))

        Text(
            text = "Choose the type of wallet you want to create",
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        Spacer(modifier = Modifier.height(24.dp))

        // Wallet Type Cards
        WalletType.entries.forEach { type ->
            WalletTypeCard(
                walletType = type,
                isSelected = selectedType == type,
                onClick = { onTypeSelected(type) }
            )
            Spacer(modifier = Modifier.height(12.dp))
        }

        Spacer(modifier = Modifier.weight(1f))

        Button(
            onClick = onNext,
            modifier = Modifier.fillMaxWidth(),
            shape = RoundedCornerShape(12.dp)
        ) {
            Text("Continue")
        }
    }
}

@Composable
fun WalletTypeCard(
    walletType: WalletType,
    isSelected: Boolean,
    onClick: () -> Unit
) {
    val (title, description, icon) = when (walletType) {
        WalletType.BITCOIN -> Triple(
            "Bitcoin Wallet",
            "Secure Bitcoin wallet with BIP32/BIP39",
            Icons.Default.CurrencyBitcoin
        )

        WalletType.ETHEREUM -> Triple(
            "Ethereum Wallet",
            "Ethereum, ERC20 tokens & smart contracts",
            Icons.Default.Diamond
        )

        WalletType.MULTICHAIN -> Triple(
            "Multi-Chain Wallet",
            "Bitcoin, Ethereum, Polygon, BSC in one wallet",
            Icons.Default.AccountBalanceWallet
        )

        else -> Triple(
            "Crypto Wallet",
            "General cryptocurrency wallet",
            Icons.Default.AccountBalanceWallet
        )
    }

    Card(
        onClick = onClick,
        modifier = Modifier.fillMaxWidth(),
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(
            containerColor = if (isSelected) {
                MaterialTheme.colorScheme.primaryContainer
            } else {
                MaterialTheme.colorScheme.surfaceVariant
            }
        ),
        border = if (isSelected) {
            BorderStroke(2.dp, MaterialTheme.colorScheme.primary)
        } else null
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = icon,
                contentDescription = title,
                modifier = Modifier.size(32.dp),
                tint = if (isSelected) {
                    MaterialTheme.colorScheme.primary
                } else {
                    MaterialTheme.colorScheme.onSurfaceVariant
                }
            )

            Spacer(modifier = Modifier.width(16.dp))

            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = title,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = description,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            if (isSelected) {
                Icon(
                    imageVector = Icons.Default.CheckCircle,
                    contentDescription = "Selected",
                    tint = MaterialTheme.colorScheme.primary
                )
            }
        }
    }
}

@Composable
fun MnemonicBackupStep(
    mnemonic: List<String>,
    onNext: () -> Unit
) {
    var showWarning by remember { mutableStateOf(true) }

    if (showWarning) {
        SecurityWarningDialog(
            onAccept = { showWarning = false },
            onCancel = { /* Navigate back */ }
        )
    }

    Column {
        Text(
            text = "Backup Recovery Phrase",
            style = MaterialTheme.typography.headlineSmall,
            fontWeight = FontWeight.Bold
        )

        Spacer(modifier = Modifier.height(8.dp))

        Text(
            text = "Write down these 12 words in order. This is the ONLY way to restore your wallet.",
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.error
        )

        Spacer(modifier = Modifier.height(24.dp))

        // Mnemonic Grid
        LazyVerticalGrid(
            columns = GridCells.Fixed(3),
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            items(mnemonic) { word ->
                MnemonicWordChip(
                    word = word,
                    index = mnemonic.indexOf(word) + 1
                )
            }
        }

        Spacer(modifier = Modifier.height(32.dp))

        Text(
            text = "‚ö†Ô∏è Never share your recovery phrase with anyone",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.error,
            textAlign = TextAlign.Center,
            modifier = Modifier.fillMaxWidth()
        )

        Spacer(modifier = Modifier.weight(1f))

        Button(
            onClick = onNext,
            modifier = Modifier.fillMaxWidth(),
            shape = RoundedCornerShape(12.dp)
        ) {
            Text("I've Backed Up My Phrase")
        }
    }
}

@Composable
fun MnemonicWordChip(word: String, index: Int) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        shape = RoundedCornerShape(8.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant
        )
    ) {
        Column(
            modifier = Modifier.padding(12.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = "$index.",
                style = MaterialTheme.typography.labelSmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Text(
                text = word,
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.Medium
            )
        }
    }
}

@Composable
fun SecurityWarningDialog(
    onAccept: () -> Unit,
    onCancel: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onCancel,
        title = {
            Text(
                text = "‚ö†Ô∏è Security Warning",
                color = MaterialTheme.colorScheme.error
            )
        },
        text = {
            Text(
                text = "Your recovery phrase is the ONLY way to restore your wallet. " +
                        "If you lose it, you lose access to your funds permanently. " +
                        "Never share it with anyone!",
                style = MaterialTheme.typography.bodyMedium
            )
        },
        confirmButton = {
            TextButton(onClick = onAccept) {
                Text("I Understand")
            }
        },
        dismissButton = {
            TextButton(onClick = onCancel) {
                Text("Cancel")
            }
        }
    )
}

@Composable
fun MnemonicDisplayStep(
    mnemonic: List<String>,
    onNext: () -> Unit,
    onBack: () -> Unit
) {
    var hasWrittenDown by remember { mutableStateOf(false) }
    var hasStoredSafely by remember { mutableStateOf(false) }

    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(bottom = 100.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Header
        item {
            Column(
                modifier = Modifier.padding(horizontal = 16.dp)
            ) {
                Text(
                    text = "üîê Your Recovery Phrase",
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold
                )

                Spacer(modifier = Modifier.height(8.dp))

                // Critical warning
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.errorContainer
                    ),
                    elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
                ) {
                    Column(
                        modifier = Modifier.padding(16.dp)
                    ) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.Warning,
                                contentDescription = "Warning",
                                tint = MaterialTheme.colorScheme.onErrorContainer
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(
                                text = "Critical Security Step",
                                style = MaterialTheme.typography.titleMedium,
                                color = MaterialTheme.colorScheme.onErrorContainer,
                                fontWeight = FontWeight.Bold
                            )
                        }

                        Spacer(modifier = Modifier.height(8.dp))

                        Text(
                            text = "Write down these 12 words IN ORDER on paper. " +
                                    "Never store digitally. This is the ONLY way to restore your wallet.",
                            color = MaterialTheme.colorScheme.onErrorContainer
                        )
                    }
                }
            }
        }

        // Mnemonic Grid
        item {
            LazyVerticalGrid(
                columns = GridCells.Fixed(3),
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp)
                    .heightIn(min = 300.dp, max = 400.dp),
                horizontalArrangement = Arrangement.spacedBy(12.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                items(mnemonic) { word ->
                    MnemonicDisplayChip(
                        word = word,
                        index = mnemonic.indexOf(word) + 1
                    )
                }
            }
        }

        // Safety Tips
        item {
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.surfaceVariant
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = "üìù Safety Checklist:",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )

                    Spacer(modifier = Modifier.height(12.dp))

                    SafetyChecklistItem(
                        text = "‚úì Write on paper (not digital)",
                        checked = true
                    )
                    SafetyChecklistItem(
                        text = "‚úì Store in secure location",
                        checked = true
                    )
                    SafetyChecklistItem(
                        text = "‚úì Never share with anyone",
                        checked = true
                    )
                    SafetyChecklistItem(
                        text = "‚úì Keep away from moisture/fire",
                        checked = true
                    )
                }
            }
        }

        // Confirmation checkboxes
        item {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp)
            ) {
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = hasWrittenDown,
                        onCheckedChange = { hasWrittenDown = it }
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text(
                        text = "I have written down all 12 words on paper",
                        style = MaterialTheme.typography.bodyMedium
                    )
                }

                Spacer(modifier = Modifier.height(8.dp))

                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = hasStoredSafely,
                        onCheckedChange = { hasStoredSafely = it }
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text(
                        text = "I have stored them in a secure location",
                        style = MaterialTheme.typography.bodyMedium
                    )
                }
            }
        }

        // Spacer to separate from buttons
        item {
            Spacer(modifier = Modifier.height(20.dp))
        }
    }

    // Fixed buttons at bottom
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.BottomCenter
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .background(
                    Brush.verticalGradient(
                        colors = listOf(
                            Color.Transparent,
                            MaterialTheme.colorScheme.surface.copy(alpha = 0.9f),
                            MaterialTheme.colorScheme.surface
                        ),
                        startY = 0f,
                        endY = 100f
                    )
                )
                .padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                OutlinedButton(
                    onClick = onBack,
                    modifier = Modifier.weight(1f),
                    shape = RoundedCornerShape(12.dp)
                ) {
                    Text("Back")
                }

                Button(
                    onClick = onNext,
                    modifier = Modifier.weight(1f),
                    shape = RoundedCornerShape(12.dp),
                    enabled = hasWrittenDown && hasStoredSafely
                ) {
                    Text("I've Backed It Up")
                }
            }
        }
    }
}

@Composable
fun MnemonicDisplayChip(
    word: String,
    index: Int
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .aspectRatio(1.2f),
        shape = RoundedCornerShape(12.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.primaryContainer,
            contentColor = MaterialTheme.colorScheme.onPrimaryContainer
        ),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "$index.",
                    style = MaterialTheme.typography.labelSmall,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.7f)
                )
                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = word,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
            }
        }
    }
}

@Composable
fun SafetyChecklistItem(text: String, checked: Boolean) {
    Row(
        verticalAlignment = Alignment.CenterVertically,
        modifier = Modifier.padding(vertical = 4.dp)
    ) {
        Icon(
            imageVector = if (checked) Icons.Default.CheckCircle else Icons.Default.Circle,
            contentDescription = null,
            tint = if (checked) MaterialTheme.colorScheme.primary
            else MaterialTheme.colorScheme.onSurfaceVariant,
            modifier = Modifier.size(20.dp)
        )
        Spacer(modifier = Modifier.width(8.dp))
        Text(text = text)
    }
}

@Composable
fun MnemonicVerificationStep(
    viewModel: WalletCreationViewModel,
    onNext: () -> Unit,
    onBack: () -> Unit
) {
    val mnemonic by viewModel.mnemonic.collectAsState()
    val enteredWords by viewModel.enteredWords.collectAsState()
    val shuffledWords = remember { mnemonic.shuffled() }

    var verificationError by remember { mutableStateOf(false) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(horizontal = 16.dp)
            .verticalScroll(rememberScrollState())
    ) {
        // Back button
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            TextButton(onClick = onBack) {
                Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                Spacer(modifier = Modifier.width(4.dp))
                Text("Back")
            }

            Text(
                text = "Step 2/3",
                style = MaterialTheme.typography.labelSmall,
                color = MaterialTheme.colorScheme.primary
            )
        }

        Spacer(modifier = Modifier.height(16.dp))

        // Title
        Text(
            text = "Verify Recovery Phrase",
            style = MaterialTheme.typography.headlineSmall,
            fontWeight = FontWeight.Bold
        )

        Spacer(modifier = Modifier.height(8.dp))

        Text(
            text = "Tap words in the correct order",
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        Spacer(modifier = Modifier.height(24.dp))

        // Selected words
        Card(
            colors = CardDefaults.cardColors(
                containerColor = MaterialTheme.colorScheme.surfaceVariant
            ),
            shape = RoundedCornerShape(12.dp)
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = "Selected Words (${enteredWords.size}/${mnemonic.size})",
                    style = MaterialTheme.typography.labelMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )

                Spacer(modifier = Modifier.height(12.dp))

                if (enteredWords.isEmpty()) {
                    Text(
                        text = "No words selected yet",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.5f),
                        textAlign = TextAlign.Center,
                        modifier = Modifier.fillMaxWidth()
                    )
                } else {
                    // Vertical FlowRow for selected words
                    FlowRow(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.spacedBy(8.dp),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        enteredWords.forEachIndexed { index, word ->
                            SimpleSelectedChip(
                                word = word,
                                index = index + 1,
                                onRemove = {
                                    viewModel.removeWordFromVerification(index)
                                }
                            )
                        }
                    }
                }
            }
        }

        Spacer(modifier = Modifier.height(24.dp))

        // Available words
        Text(
            text = "Tap to select:",
            style = MaterialTheme.typography.labelLarge,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        Spacer(modifier = Modifier.height(12.dp))

        // Manual 4-column grid
        Column(
            modifier = Modifier.fillMaxWidth()
        ) {
            for (row in 0 until 3) { // 3 rows
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    for (col in 0 until 4) { // 4 columns
                        val index = row * 4 + col
                        if (index < shuffledWords.size) {
                            val word = shuffledWords[index]
                            Box(modifier = Modifier.weight(1f)) {
                                if (!enteredWords.contains(word)) {
                                    SimpleWordChip(
                                        word = word,
                                        onClick = { viewModel.addWordToVerification(word) }
                                    )
                                } else {
                                    // Empty space for already selected words
                                    Spacer(modifier = Modifier.height(44.dp))
                                }
                            }
                        }
                    }
                }
                Spacer(modifier = Modifier.height(8.dp))
            }
        }

        Spacer(modifier = Modifier.height(32.dp))

        // Error message
        if (verificationError) {
            Card(
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.errorContainer
                ),
                shape = RoundedCornerShape(8.dp)
            ) {
                Row(
                    modifier = Modifier.padding(12.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Default.Error,
                        contentDescription = "Error",
                        tint = MaterialTheme.colorScheme.onErrorContainer,
                        modifier = Modifier.size(18.dp)
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text(
                        text = "Wrong order. Please try again.",
                        color = MaterialTheme.colorScheme.onErrorContainer
                    )
                }
            }
            Spacer(modifier = Modifier.height(16.dp))
        }

        Button(
            onClick = {
                if (viewModel.completeVerificationAndMoveNext()) {
                    verificationError = false
                    onNext() // This will notify the UI
                } else {
                    verificationError = true
                }
            },
            modifier = Modifier.fillMaxWidth(),
            shape = RoundedCornerShape(12.dp),
            enabled = enteredWords.size == mnemonic.size
        ) {
            Text("Verify & Continue")
        }

        // Bottom padding
        Spacer(modifier = Modifier.height(32.dp))
    }
}

@Composable
fun SimpleSelectedChip(
    word: String,
    index: Int,
    onRemove: () -> Unit
) {
    Card(
        onClick = onRemove,
        shape = RoundedCornerShape(8.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.primaryContainer,
            contentColor = MaterialTheme.colorScheme.onPrimaryContainer
        )
    ) {
        Row(
            modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = "$index.",
                style = MaterialTheme.typography.labelSmall,
                fontWeight = FontWeight.Bold
            )
            Spacer(modifier = Modifier.width(4.dp))
            Text(
                text = word,
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.Medium,
                maxLines = 1,
                overflow = TextOverflow.Ellipsis
            )
            Spacer(modifier = Modifier.width(4.dp))
            Icon(
                imageVector = Icons.Default.Close,
                contentDescription = "Remove",
                modifier = Modifier.size(14.dp)
            )
        }
    }
}

@Composable
fun SimpleWordChip(
    word: String,
    onClick: () -> Unit
) {
    Card(
        onClick = onClick,
        shape = RoundedCornerShape(8.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant
        ),
        border = BorderStroke(1.dp, MaterialTheme.colorScheme.outline.copy(alpha = 0.2f))
    ) {
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .height(44.dp),
            contentAlignment = Alignment.Center
        ) {
            Text(
                text = word,
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.Medium,
                maxLines = 1,
                overflow = TextOverflow.Ellipsis
            )
        }
    }
}

@Composable
fun WalletNameStep(
    walletName: String,
    onNameChange: (String) -> Unit,
    onCreate: () -> Unit
) {
    Column {
        Text(
            text = "Name Your Wallet",
            style = MaterialTheme.typography.headlineSmall,
            fontWeight = FontWeight.Bold
        )

        Spacer(modifier = Modifier.height(8.dp))

        Text(
            text = "Give your wallet a name for easy identification",
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        Spacer(modifier = Modifier.height(24.dp))

        OutlinedTextField(
            value = walletName,
            onValueChange = onNameChange,
            modifier = Modifier.fillMaxWidth(),
            label = { Text("Wallet Name") },
            placeholder = { Text("e.g., My Savings Wallet") },
            singleLine = true,
            shape = RoundedCornerShape(12.dp)
        )

        Spacer(modifier = Modifier.height(8.dp))

        Text(
            text = "Tip: Use a descriptive name like 'Savings' or 'Trading'",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        Spacer(modifier = Modifier.weight(1f))

        Button(
            onClick = onCreate,
            modifier = Modifier.fillMaxWidth(),
            shape = RoundedCornerShape(12.dp),
            enabled = walletName.isNotBlank()
        ) {
            Text("Create Wallet")
        }
    }
}

@Composable
fun WalletSuccessStep(
    wallet: CryptoWallet,
    onFinish: () -> Unit
) {
    Column(
        modifier = Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Box(
            modifier = Modifier
                .size(100.dp)
                .clip(RoundedCornerShape(50.dp))
                .background(MaterialTheme.colorScheme.primaryContainer),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                imageVector = Icons.Default.CheckCircle,
                contentDescription = "Success",
                modifier = Modifier.size(48.dp),
                tint = MaterialTheme.colorScheme.primary
            )
        }

        Spacer(modifier = Modifier.height(32.dp))

        Text(
            text = "Wallet Created Successfully!",
            style = MaterialTheme.typography.headlineMedium,
            fontWeight = FontWeight.Bold,
            textAlign = TextAlign.Center
        )

        Spacer(modifier = Modifier.height(8.dp))

        // Show wallet info
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 24.dp),
            shape = RoundedCornerShape(16.dp)
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = "Wallet Details",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )

                Spacer(modifier = Modifier.height(12.dp))

                Row {
                    Text("Name: ", fontWeight = FontWeight.Medium)
                    Text(wallet.name)
                }

                Spacer(modifier = Modifier.height(4.dp))

                Row {
                    Text("Type: ", fontWeight = FontWeight.Medium)
                    Text(wallet.walletType.name)
                }

                Spacer(modifier = Modifier.height(4.dp))

                Row {
                    Text("Address: ", fontWeight = FontWeight.Medium)
                    Text(
                        text = wallet.address.take(12) + "..." + wallet.address.takeLast(8),
                        style = MaterialTheme.typography.bodySmall,
                        fontFamily = FontFamily.Monospace
                    )
                }
            }
        }

        Spacer(modifier = Modifier.height(32.dp))

        Button(
            onClick = onFinish,
            modifier = Modifier.fillMaxWidth(0.8f),
            shape = RoundedCornerShape(12.dp)
        ) {
            Text("Go to Dashboard")
        }
    }
}